module UseVoronoiBin
using CubeFitter, VoronoiBinning, NaNStatistics, Measurements
using Measurements: value, uncertainty

function prepare_slice(inslice::AbstractArray; which_flux=:fit)
    ### Don't know if the :both option is any good but it is worth
    # spending a bit more time testing out.
    if which_flux == :both
        sn1 = inslice[:,:,4] .± inslice[:, :, 5]
        sn2 = inslice[:,:,1] .± inslice[:, :, 2]
        sns = stack((sn1, sn2), dims=3)
        snm = nanmean(sns, dim=3)
        S, N = value.(snm), uncertainty.(snm)
        println("Sizes of S and N: $(size(S)), $(size(N))")
    else
        slaydict = Dict(:fit => 1, :numeric => 4)
        nlaydict = Dict(:fit => 2, :numeric => 5)
        Slayer = slaydict[which_flux]
        Nlayer = nlaydict[which_flux]
        println("Using layers $Slayer and $Nlayer")
        S = inslice[:, :, Slayer]
        N = inslice[:, :, Nlayer]
        println("Sizes of S and N: $(size(S)), $(size(N))")
    end
    N = ifelse.(N .> 0, N, nanmaximum(N))
    N = ifelse.(isnan.(N), nanmaximum(N), N)
    return S, N
end


"""    voronoi_bin_slice()
The actual `voronoi_bin_slice` function, not the dummy one.

## Arguments:
Required arguments
- `slice_dict::Dict`: The slice_dict, generated by the CubeFitter routines, 
  containing the slices/maps.
- `key::Symbol`: The quantity map based on which to 
Keyword arguments
- `which_flux::Symbol`: Whether to base the binning on fitted (`:fit`) or numerical (`:numeric`) fluxes.
   Currently, only numerical fluxes work.
Keyword arguments passed to `voronoi2Dbinning`
- `target_sn::AbstractFloat`: The S/N ratio to target for the Voronoi binning. 
- `min_sn::AbstractFloat`: Minimum S/N ratio (not used at the moment).
- `verbose::Bool`: Whether or not you want to see extra diagnostic output from the voronoi2Dbinning
   function.
- `plot::Bool`: Whether or not to plot the output 
  (doesn't work for me but keeping it in anyway. Requires PyPlot installed).
"""
function CubeFitter.voronoi_bin_slice(
    slice_dict, key; 
    target_sn=10., #min_sn=1., 
    bin_strategy=WeightedVoronoi, verbose=false, plot=false,
    return_all_vorbin_output=false,
    which_flux=:fit)
    slice = slice_dict[key]
    s, n = prepare_slice(slice, which_flux=which_flux)
    println("Size of slice: $(size(s))")
    S = Iterators.flatten(s) |> collect
    N = Iterators.flatten(n) |> collect
    println("Voronoibinnerfunc: $(filter(N -> N .< 0, N))")
    x = Iterators.cycle(1:size(s)[1], size(s)[2]) |> collect
    xy = reshape(x, size(s))
    y = Iterators.flatten(xy') |> collect
    outs = voronoi2Dbinning(
        x, y, S, N, target_sn,
        verbose=false, 
        plot=false,
    )
    binmap =  reshape(outs[1], size(s))
    datamap = mean_by_fragmap(s, binmap, errs=n)
    if return_all_vorbin_output
        return binmap, datamap, outs 
    else 
        return binmap, datamap
    end
end

###=============================================================================
#   TODO: Find a way to generate a random colormap to display the fragmap
#   TODO: Find a way to better handle NaN's such that we can also use the fitted 
#         values. 
###=============================================================================
end
